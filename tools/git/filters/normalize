#!/usr/bin/python
# EMACS settings: -*-  tab-width: 2; indent-tabs-mode: t; python-indent-offset: 2 -*-
# vim: tabstop=2:shiftwidth=2:noexpandtab
# kate: tab-width 2; replace-tabs off; indent-width 2;
#
# ==============================================================================
# Authors:               Thomas B. Preusser
#
# License:
# ==============================================================================
# Copyright 2007-2016 Technische Universitaet Dresden - Germany
#                     Chair for VLSI-Design, Diagnostics and Architecture
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
"""
Provides implementations for 'smudge' and 'clean' filters for the sources
within the PoC repo.

It applies a WhiteIndent filter to all inputs in order to "clean" spaces out of
otherwise empty lines or to "smudge" whitespace according to the context
indentation into them.

VHDL sources are further normalized by putting all reserved words into lower
case by a "clean" run.

Synopsis:

> normalize (smudge|clean) [lang]

Only "vhdl" as lang is currently understood and triggers the insertion of the
extra filter.
"""
import sys
import re

##############################################################################
class Filter:
	def __init__(self, source):
		self._source = source

	def __iter__(self):
		source = self._source
		for line in source:
			yield  self.filter(line)

##############################################################################
class WhiteIndent(Filter):
	def __init__(self, source):
		self._source = source
		self._indent = ''

	def filter(self, line):
		m = re.match('^(\s*)\S', line)
		if m:
			self._indent = m.group(1)
			return  line
		return  self._indent

##############################################################################
class VhdlCap(Filter):
  # VHDL reserved words and standard types
	reserved_words = set("""
    abs after alias all and architecture array assert attribute
    begin block body buffer bus
    case component configuration constant
    disconnect downto
    else elsif end entity exit
    file for function
    generate generic group guarded
    if impure in inertial inout is
    label library linkage literal loop
    map mod
    nand new next nor not null
    of on open or others out
    package port postponed procedure process pure
    range record register reject rem report return rol ror
    select severity signal shared sla sll sra srl subtype
    then to transport type
    unaffected units until use
    variable
    wait when while with
    xnor xor

    bit bit_vector boolean character integer natural positive signed
    std_logic std_logic_vector string time unsigned
    """.split())

  # Match all identifiers outside of strings and comments,
  #  match those as complete words so as to skip them
	reserved_pattern = re.compile(r'--.*$|(["\\\']).*?\1|\b('+'|'.join(reserved_words)+r')\b', re.I)

	@staticmethod
	def normalize_match(match):
		w = match.group(2)
		return  w.lower() if w else match.group(0)

	def __init__(self, source):
		self._source = source

	def filter(self, line):
		return  VhdlCap.reserved_pattern.sub(VhdlCap.normalize_match, line)

##############################################################################
# Build Filter Chain
chain = (l.rstrip() for l in sys.stdin)
if(len(sys.argv) > 1):
	if(sys.argv[1] == 'clean'):
		if(len(sys.argv) > 2):
			if(sys.argv[2] == 'vhdl'):
				chain = VhdlCap(chain)
	elif(sys.argv[1] == 'smudge'):
		chain = WhiteIndent(chain)

##############################################################################
# Execute
for l in chain:
    print(l)
